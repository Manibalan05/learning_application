const { databases, users } = require('../config/appwrite');
const { Query, ID } = require('node-appwrite');

const getAllProblems = async (req, res) => {
    try {
        // 1. Get User ID from headers
        const userId = req.headers['user-id'];

        // 2. Validate Input
        if (!userId) {
            return res.status(401).json({ error: 'Unauthorized: Missing User ID' });
        }

        // 3. Verify User Role (Student or Admin)
        const user = await users.get(userId);
        const hasAccess = user.labels && (user.labels.includes('student') || user.labels.includes('admin'));

        if (!hasAccess) {
            return res.status(403).json({ error: 'Forbidden: Access denied' });
        }

        // 4. Fetch Problems from Appwrite
        const databaseId = process.env.APPWRITE_DATABASE_ID;
        const collectionId = 'problems'; 

        const response = await databases.listDocuments(
            databaseId,
            collectionId,
            [
                Query.orderDesc('createdAt') // Show newest problems first
            ]
        );

        // 5. Format the Data
        const problems = response.documents.map(doc => ({
            problemId: doc.$id, // This is the unique ID generated by Appwrite
            title: doc.title,
            description: doc.description,
            difficulty: doc.difficulty
        }));

        // 6. Return Response
        return res.status(200).json({
            message: 'Problems fetched successfully',
            count: problems.length,
            problems
        });

    } catch (error) {
        console.error('Error fetching problems:', error);

        if (error.code === 404) {
             return res.status(404).json({ error: 'User not found or invalid ID' });
        }

        return res.status(500).json({ error: 'Internal Server Error' });
    }
};

const axios = require('axios');

// Judge0 Language IDs (CE)
const LANGUAGE_MAPPING = {
    'c': 50,      // GCC 9.2.0
    'cpp': 54,    // GCC 9.2.0
    'java': 62,   // OpenJDK 13.0.1
    'python': 71  // Python 3.8.1
};

const { calculateAIScore } = require('../utils/aiDetector');

// ... (previous imports and language mapping)

const submitProblem = async (req, res) => {
    try {
        const userId = req.headers['user-id'];
        
        // Extract Metadata for AI Detection along with standard fields
        // Frontend should now send: pasteCount, timeSpentMs, totalKeyPresses
        const { 
            problemId, 
            language, 
            code,
            pasteCount,      // Optional
            timeSpentMs,     // Optional
            totalKeyPresses  // Optional 
        } = req.body;

        // 1. Basic Validation
        if (!userId) return res.status(401).json({ error: 'Unauthorized: Missing User ID' });
        if (!problemId || !language || !code) return res.status(400).json({ error: 'All fields required' });

        // 2. Verify User Role
        const user = await users.get(userId);
        const isStudent = user.labels && user.labels.includes('student');
        if (!isStudent) return res.status(403).json({ error: 'Forbidden: Only students can submit code' });

        // 3. AI Detection Logic
        // Run this BEFORE execution to save resources if needed, or largely parallel
        const aiAnalysis = calculateAIScore(code, {
            pasteCount: pasteCount || 0,
            timeSpentMs: timeSpentMs || 0,
            totalKeyPresses: totalKeyPresses || 0
        });

        const aiScore = aiAnalysis.score;
        const aiReasons = aiAnalysis.details; // Optional: Store reason text if schema allows

        // 4. Get Problem Details (for Test Cases)
        const problem = await databases.getDocument(
            process.env.APPWRITE_DATABASE_ID,
            'problems',
            problemId
        );

        if (!problem) return res.status(404).json({ error: 'Problem not found' });

        // Parse testCases
        let testCases = [];
        try {
            testCases = JSON.parse(problem.testCases || '[]');
        } catch (e) {
            console.error('Error parsing test cases', e);
        }

        const firstTestCaseInput = testCases.length > 0 ? testCases[0].input : '';
        const languageId = LANGUAGE_MAPPING[language];

        if (!languageId) return res.status(400).json({ error: 'Unsupported language' });

        // 5. Send to Judge0
        const judge0Response = await axios.post(
            'https://ce.judge0.com/submissions?base64_encoded=false&wait=true',
            {
                source_code: code,
                language_id: languageId,
                stdin: firstTestCaseInput
            }
        );

        const result = judge0Response.data;
        
        // Extract Details
        const executionTime = result.time ? parseFloat(result.time) : 0;
        const status = result.status ? result.status.description : 'Unknown';
        const stdout = result.stdout || '';
        const stderr = result.stderr || '';
        const compileOutput = result.compile_output || '';

        // Check success
        let isSuccess = false;
        if (testCases.length > 0) {
            const expectedOutput = testCases[0].output.trim();
            const actualOutput = stdout.trim();
            if (status === 'Accepted' && actualOutput === expectedOutput) {
                isSuccess = true;
            }
        } else {
             isSuccess = status === 'Accepted';
        }

        // 6. Save Submission to Appwrite
        const newSubmission = await databases.createDocument(
            process.env.APPWRITE_DATABASE_ID,
            'submissions', 
            ID.unique(),
            {
                userId,
                problemId,
                language,
                code,
                executionTime,
                aiScore, // Calculated Score
                createdAt: new Date().toISOString(),
                status, 
                output: stdout || stderr || compileOutput
            }
        );

        return res.status(201).json({
            message: 'Code submitted and executed',
            submissionId: newSubmission.$id,
            executionResult: {
                status,
                time: executionTime,
                stdout,
                stderr,
                passed: isSuccess
            },
            aiAnalysis: {
                score: aiScore,
                reasons: aiReasons
            }
        });

    } catch (error) {
        console.error('Error in submission flow:', error);
        if (error.code === 404) return res.status(404).json({ error: 'Resource not found' });
        return res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
};

const getStudentSubmissions = async (req, res) => {
    try {
        const userId = req.headers['user-id'];
        
        if (!userId) {
            return res.status(401).json({ error: 'Unauthorized: Missing User ID of student' });
        }

        const databaseId = process.env.APPWRITE_DATABASE_ID;
        const collectionId = 'submissions';

        // Fetch submissions for this specific user
        const response = await databases.listDocuments(
            databaseId,
            collectionId,
            [
                Query.equal('userId', userId),
                Query.orderDesc('createdAt'),
                Query.limit(50) // Limit history
            ]
        );
        
        // Optimally, we would join with 'problems' collection to get titles,
        // but Appwrite NO-SQL doesn't support joins easily. 
        // We will fetch problem titles in a second step or let frontend handle it if data is small.
        // For standard MERN, we'd use .populate(). Here we'll just return raw data 
        // and ideally the frontend matches IDs if it has the problem list loaded.
        // OR we quickly fetch problems map.
        
        // Let's keep it simple: Return the submission data.
        const submissions = response.documents.map(doc => ({
            id: doc.$id,
            problemId: doc.problemId,
            language: doc.language,
            code: doc.code,
            status: doc.status,
            executionTime: doc.executionTime,
            aiScore: doc.aiScore,
            createdAt: doc.createdAt,
            output: doc.output
        }));

        return res.json({ submissions });

    } catch (error) {
        console.error('Fetch Submissions Error:', error);
        return res.status(500).json({ error: 'Internal Server Error' });
    }
};

module.exports = { getAllProblems, submitProblem, getStudentSubmissions };
