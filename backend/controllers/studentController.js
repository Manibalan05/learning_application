const { databases, users } = require('../config/appwrite');
const { Query, ID } = require('node-appwrite');

const getAllProblems = async (req, res) => {
    try {
        // 1. Get User ID from headers
        const userId = req.headers['user-id'];

        // 2. Validate Input
        if (!userId) {
            return res.status(401).json({ error: 'Unauthorized: Missing User ID' });
        }

        // 3. Verify User Context (Optional for viewing, required for submitting)
        // For development/demo, we allow any authenticated user to view problems
        // to avoid "Empty Page" if labels aren't set manually in Appwrite.
        const user = await users.get(userId);
        if (!user) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        // 4. Fetch Problems from Appwrite
        const databaseId = process.env.APPWRITE_DATABASE_ID;
        const collectionId = 'problems'; 

        const response = await databases.listDocuments(
            databaseId,
            collectionId,
            [
                Query.orderDesc('$createdAt') // Use built-in system attribute
            ]
        );

        // 5. Format the Data
        const problems = response.documents.map(doc => ({
            problemId: doc.$id, // This is the unique ID generated by Appwrite
            title: doc.title,
            description: doc.description,
            difficulty: doc.difficulty
        }));

        // 6. Return Response
        return res.status(200).json({
            message: 'Problems fetched successfully',
            count: problems.length,
            problems
        });

    } catch (error) {
        console.error('Error in getAllProblems:', error);
        return res.status(500).json({ error: 'Internal Server Error', message: error.message });
    }
};

const axios = require('axios');

// Judge0 Language IDs (CE)
const LANGUAGE_MAPPING = {
    'c': 50,      // GCC 9.2.0
    'cpp': 54,    // GCC 9.2.0
    'java': 62,   // OpenJDK 13.0.1
    'python': 71  // Python 3.8.1
};

const { calculateAIScore } = require('../utils/aiDetector');

// ... (previous imports and language mapping)

const submitProblem = async (req, res) => {
    try {
        const userId = req.headers['user-id'];
        
        // Extract Metadata
        const { 
            problemId, 
            language, 
            code,
            userInput,       // New: User provided input for "Run Code"
            pasteCount,
            timeSpentMs,
            totalKeyPresses,
            isFinalSubmission
        } = req.body;

        // 1. Basic Validation
        if (!userId) return res.status(401).json({ error: 'Unauthorized: Missing User ID' });
        if (!problemId || !language || !code) return res.status(400).json({ error: 'All fields required' });

        // 2. Verify User
        try {
            const user = await users.get(userId);
            if (!user) return res.status(401).json({ error: 'Unauthorized' });
        } catch (e) {
            console.error('User verification failed:', e.message);
            return res.status(401).json({ error: 'Invalid User Session' });
        }

        // 3. AI Detection Logic
        let aiScore = 0;
        let aiReasons = [];
        try {
            const aiAnalysis = calculateAIScore(code, {
                pasteCount: pasteCount || 0,
                timeSpentMs: timeSpentMs || 0,
                totalKeyPresses: totalKeyPresses || 0
            });
            aiScore = aiAnalysis.score;
            aiReasons = aiAnalysis.details;
        } catch (e) {
            console.error('AI Calculation Error:', e);
            // Non-critical, continue with 0
        }

        // 4. Get Problem Details
        let problem;
        try {
            problem = await databases.getDocument(
                process.env.APPWRITE_DATABASE_ID,
                'problems',
                problemId
            );
        } catch (e) {
            console.error('Problem Fetch Error:', e);
            return res.status(404).json({ error: 'Problem not found or database error' });
        }

        // Parse testCases
        let testCases = [];
        try {
            testCases = JSON.parse(problem.testCases || '[]');
        } catch (e) {
            console.error('Error parsing test cases', e);
        }

        // Determine Input to Use
        // If Final Submission -> Use Test Case Input (Correctness Check)
        // If Test Run -> Use User Input (if provided), else default to Test Case Input
        const firstTestCaseInput = testCases.length > 0 ? testCases[0].input : '';
        let stdInToUse = firstTestCaseInput;
        
        if (!isFinalSubmission && userInput !== undefined && userInput !== null) {
            stdInToUse = userInput;
        }

        // Validation: Warn if code expects input but none provided
        // Matches: input(), Scanner, System.in, scanf, cin, getline, sys.stdin
        const requiresInput = /input\(|Scanner|System\.in|scanf|cin|getline|sys\.stdin/.test(code);
        
        // Only trigger error if strictly empty and looks like it needs input
        if (requiresInput && (!stdInToUse || !stdInToUse.toString().trim())) {
            return res.status(400).json({
                error: 'Input Required',
                message: 'Your code appears to expect input, but no Input was provided.',
                details: 'Please enter values in the "Custom Input" box below the editor.'
            });
        }

        const languageId = LANGUAGE_MAPPING[language];

        if (!languageId) return res.status(400).json({ error: 'Unsupported language' });

        // 5. Send to Judge0
        let isSuccess = false;
        let executionTime = 0;
        let status = 'Unknown';
        let stdout = '';
        let stderr = '';
        let compileOutput = '';

        try {
            // Helper for Base64
            const toBase64 = (str) => Buffer.from(String(str || '')).toString('base64');
            const fromBase64 = (str) => Buffer.from(String(str || ''), 'base64').toString('utf-8');

            console.log('Preparing Judge0. Mode:', isFinalSubmission ? 'SUBMIT' : 'RUN');
            console.log('Input:', stdInToUse);

            const judge0Response = await axios.post(
                'https://ce.judge0.com/submissions?base64_encoded=true&wait=true',
                {
                    source_code: toBase64(code),
                    language_id: languageId,
                    stdin: toBase64(stdInToUse)
                }
            );
            
            const result = judge0Response.data;
            executionTime = result.time ? parseFloat(result.time) : 0;
            status = result.status ? result.status.description : 'Unknown';
            stdout = fromBase64(result.stdout);
            stderr = fromBase64(result.stderr);
            compileOutput = fromBase64(result.compile_output);

            console.log('Judge0 Execution Result:', { status, stdout, stderr });

            // Check success
            if (testCases.length > 0) {
                const expectedOutput = (testCases[0].output || '').toString().trim();
                const actualOutput = stdout.trim();
                
                // Compare (relaxed)
                if (status === 'Accepted' && actualOutput === expectedOutput) {
                    isSuccess = true;
                }
            } else {
                 isSuccess = status === 'Accepted';
            }

        } catch (e) {
            console.error('Judge0 Execution Error:', e.message);
            if (e.response) {
                 console.error('Judge0 Response:', e.response.data);
            }
            // If execution fails, we might still want to return error to user instead of crashing
            return res.status(502).json({ 
                error: 'Code Execution Failed', 
                message: 'Unable to execute code via Judge0. Is the API reachable?',
                details: e.message
            });
        }

        // 6. Save Submission to Appwrite
        let submissionId = null;
        
        if (isFinalSubmission) {
            try {
                // TRUNCATE OUTPUT to prevent database errors (assuming 5000 char limit for safety)
                const rawOutput = stdout || stderr || compileOutput || '';
                const displayOutput = rawOutput.substring(0, 5000); 

                const submissionData = {
                    userId: userId,
                    problemId: problemId,
                    language: language,
                    code: code, 
                    executionTime: parseFloat(executionTime) || 0.0,
                    aiscore: parseInt(aiScore) || 0,
                    status: status || 'Unknown', 
                    output: displayOutput
                };

                console.log('Saving final submission:', submissionData);

                const newSubmission = await databases.createDocument(
                    process.env.APPWRITE_DATABASE_ID,
                    'submissions', 
                    ID.unique(),
                    submissionData
                );
                
                submissionId = newSubmission.$id;

            } catch (e) {
                console.error('Database Save Error:', e);
                // Return 500 but with specific message
                return res.status(500).json({ 
                    error: 'Database Save Failed', 
                    message: 'Could not save submission to database. Check Appwrite attributes.',
                    details: e.message
                });
            }
        } 

        return res.status(201).json({
            message: isFinalSubmission ? 'Solution submitted successfully' : 'Code executed (test run)',
            submissionId: submissionId,
            isFinalSubmission: isFinalSubmission || false,
            executionResult: {
                status,
                time: executionTime,
                stdout,
                stderr,
                passed: isSuccess
            },
            aiAnalysis: {
                score: aiScore,
                reasons: aiReasons
            }
        });

    } catch (error) {
        console.error('FULL SUBMISSION ERROR:', error);
        return res.status(500).json({ 
            error: 'Internal Server Error', 
            message: error.message || 'Unknown backend error',
            code: error.code || 500
        });
    }
};

const getStudentSubmissions = async (req, res) => {
    try {
        const userId = req.headers['user-id'];
        
        if (!userId) {
            return res.status(401).json({ error: 'Unauthorized: Missing User ID of student' });
        }

        const databaseId = process.env.APPWRITE_DATABASE_ID;
        const collectionId = 'submissions';

        // Fetch submissions for this specific user
        const response = await databases.listDocuments(
            databaseId,
            collectionId,
            [
                Query.equal('userId', userId),
                Query.orderDesc('createdAt'),
                Query.limit(50) // Limit history
            ]
        );
        
        // Optimally, we would join with 'problems' collection to get titles,
        // but Appwrite NO-SQL doesn't support joins easily. 
        // We will fetch problem titles in a second step or let frontend handle it if data is small.
        // For standard MERN, we'd use .populate(). Here we'll just return raw data 
        // and ideally the frontend matches IDs if it has the problem list loaded.
        // OR we quickly fetch problems map.
        
        // Let's keep it simple: Return the submission data.
        const submissions = response.documents.map(doc => ({
            id: doc.$id,
            problemId: doc.problemId,
            language: doc.language,
            code: doc.code,
            status: doc.status,
            executionTime: doc.executionTime,
            aiScore: doc.aiscore || 0,
            createdAt: doc.createdAt,
            output: doc.output
        }));

        return res.json({ submissions });

    } catch (error) {
        console.error('Fetch Submissions Error:', error);
        return res.status(500).json({ error: 'Internal Server Error' });
    }
};


const submitCode = async (req, res) => {
    try {
        const userId = req.headers['user-id'];
        const { problemId, language, code } = req.body;

        // 1. Validations
        if (!userId) return res.status(401).json({ error: 'Unauthorized: Missing User ID' });
        if (!problemId || !language || !code) return res.status(400).json({ error: 'All fields (problemId, language, code) are required' });

        // 2. Verify User is Student
        const user = await users.get(userId);
        const isStudent = user.labels && user.labels.includes('student');
        if (!isStudent) {
            // For demo flexibility we generally allowed it, but Requirement is STRICT here.
            return res.status(403).json({ error: 'Forbidden: Only students can submit code' });
        }

        // 3. Store Submission
        // Note: providing default values for fields required by existing schema but not relevant to this flow
        const submissionData = {
            userId,
            problemId,
            language,
            code,
            status: 'Submitted',     // Default status
            output: 'N/A',           // No execution output
            executionTime: 0.0,      // No execution
            aiscore: 0               // No AI analysis
        };

        const newSubmission = await databases.createDocument(
            process.env.APPWRITE_DATABASE_ID,
            'submissions',
            ID.unique(),
            submissionData
        );

        return res.status(201).json({
            message: 'Code submitted successfully',
            submissionId: newSubmission.$id,
            createdAt: newSubmission.$createdAt
        });

    } catch (error) {
        console.error('Submit Code Error:', error);
        return res.status(500).json({ error: 'Internal Server Error', message: error.message });
    }
};

module.exports = { getAllProblems, submitProblem, getStudentSubmissions, submitCode };
